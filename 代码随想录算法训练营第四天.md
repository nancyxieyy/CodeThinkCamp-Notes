# 代码随想录算法训练营第四天 | 24.两两交换链表中的节点 、19.删除链表的倒数第N个节点、面试题 02.07. 链表相交、142.环形链表II

## 一、LeetCode 题目打卡

### 24.两两交换链表中的节点

- 使用虚拟头节点 `dummy`，简化头节点交换时的处理；

- 设置指针 `cur`，每轮检查 `cur.next` 和 `cur.next.next` 是否存在，以判断是否有一对可以交换；

- 通过临时变量保存第一个节点，按顺序重连指针完成局部反转：**第二个 → 第一个 → 第三个**；

- 每次交换后，`cur` 向前推进两个节点，继续处理下一组。


🔗 [题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/) 
📖 [题解文章](https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html) 
🎬 [视频讲解](https://www.bilibili.com/video/BV1YT411g7br?vd_source=11d8a2565cfbaf066f9ce055732e8faf&spm_id_from=333.788.videopod.sections)

![截圖 2025-08-03 11.35.04](/Users/nancyxie/Library/Application Support/typora-user-images/截圖 2025-08-03 11.35.04.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        dummy = ListNode(0)
        dummy.next = head
        cur = dummy
        while(cur.next is not None and cur.next.next is not None):
            tmp = cur.next  # 保存第一个节点
            cur.next = cur.next.next    # cur的下一个指向第二个节点
            tmp.next = cur.next.next    # 第一个节点的下一个指向第三个节点
            cur.next.next = tmp # 第二个节点的下一个指向第一个节点
            cur = cur.next.next # cur移动到下一组目标节点的前面一个
        return dummy.next
```

### 19.删除链表的倒数第N个节点

- 使用虚拟头节点 `dummy` 统一处理删除头节点的特殊情况

- 设置快慢指针 `fast` 和 `slow`，初始都指向 `dummy`

- 让 `fast` 先走 `n+1` 步，形成长度为 `n` 的间距

- 然后 `fast` 和 `slow` 同步前进，直到 `fast` 指向末尾

- 此时 `slow.next` 就是待删除节点，执行 `slow.next = slow.next.next` 完成删除


🔗 [题目链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
📖 [题解文章](https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html)
🎬 [视频讲解](https://www.bilibili.com/video/BV1vW4y1U7Gf?vd_source=11d8a2565cfbaf066f9ce055732e8faf&spm_id_from=333.788.videopod.sections)

![截圖 2025-08-03 12.05.35](/Users/nancyxie/Library/Application Support/typora-user-images/截圖 2025-08-03 12.05.35.png)

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: Optional[ListNode]
        :type n: int
        :rtype: Optional[ListNode]
        """
        dummy = ListNode(0)
        dummy.next = head
        slow = dummy
        fast = dummy
        while((n+1) > 0 and fast is not None):
            fast = fast.next
            n -= 1
            
        while(fast is not None):
            slow = slow.next
            fast = fast.next
        slow.next = slow.next.next
        return dummy.next
```

### 面试题 02.07. 链表相交

- 本题考查的是链表相交时，两个指针如何对齐长度差找到相交点
- 解法通过双指针交叉遍历两个链表，让它们在第二次遍历时同步到达交点或同时为 None
- 相交判断基于“节点地址相同”，不是值相等
- 时间复杂度 O(n + m)，空间 O(1)，逻辑清晰且无需额外数据结构

🔗 [题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)
📖 [题解文章](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html)
![截圖 2025-08-03 12.39.12](/Users/nancyxie/Library/Application Support/typora-user-images/截圖 2025-08-03 12.39.12.png)

```Python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        if headA is not None and headB is not None:
            pA = headA
            pB = headB

            while pA != pB:
                pA = pA.next if pA else headB
                pB = pB.next if pB else headA

            return pA
  
        else:
            return None
```

### 142.环形链表II

- 快慢指针：`fast` 每次走两步，`slow` 每次走一步；若有环，它们一定会在环中相遇
- 相遇后，将一个指针移到头结点，两个指针每次都走一步
- 再次相遇的位置，就是环的入口
- 该方法利用了公式：`head 到入口距离 = 相遇点再走到入口的距离`

🔗 [题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/description/)
📖 [题解文章](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html)
🎬 [视频讲解](https://www.bilibili.com/video/BV1if4y1d7ob?vd_source=11d8a2565cfbaf066f9ce055732e8faf&spm_id_from=333.788.videopod.sections)

![截圖 2025-08-03 13.01.07](/Users/nancyxie/Library/Application Support/typora-user-images/截圖 2025-08-03 13.01.07.png)

```Python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        slow = head
        fast = head
        while(fast is not None and fast.next is not None):
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                index1 = slow
                index2 = head
                while(index1 is not index2):
                    index1 = index1.next
                    index2 = index2.next
                return index1
        return None
```

## 今日总结

- 📌 今天共完成三道题目，覆盖以下链表基础核心操作：
  1. **24.两两交换链表中的节点 ：**
     - 理解每组节点交换需重新连接三条指针，顺序不能错；
     - 使用虚拟头节点处理首节点交换问题，统一链表结构；
     - 每轮迭代移动两步，精确控制指针推进位置。
  2. **19.删除链表的倒数第N个节点：**
     - 运用快慢指针制造间隔，确保 `slow` 指向待删除节点前一位；
     - 快指针先走 `n+1` 步，慢指针再同步推进；
     - 虚拟头节点有效避免头结点被删的特殊处理。
  3. **面试题 02.07. 链表相交：**
     - 使用双指针法对齐长度差，最终在交点同步相遇；
     - 判断相交是基于节点地址而非值是否相等；
     - 如果不相交，两指针最终都会为 `None`。
  4. **142.环形链表II：**
     - 快慢指针判断是否有环，并在环中第一次相遇；
     - 相遇后让一指针从头出发，另一指针从相遇点出发，同速前进；
     - 两指针再次相遇的地方即是环的入口点，公式推导确保一致。

------

🧠 总结反思：

- 链表操作中“前一个节点”的掌控至关重要，插入、删除、反转都依赖它定位准确；
- 虚拟头节点是链表处理中不可或缺的模板手段，极大简化边界逻辑；
- 双指针是处理链表结构问题的万能解法，适用于反转、定位、中点、环检测等场景；
- 今天的练习覆盖了链表的 **交换、删除、结构分析、环定位** 四大核心能力，链表框架基本成型。
